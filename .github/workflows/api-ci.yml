name: API CI with Blue/Green Deployment

on:
  push:
    branches: [main]
    paths:
      - 'services/api/**'
      - '.github/workflows/api-ci.yml'
  pull_request:
    paths:
      - 'services/api/**'
      - '.github/workflows/api-ci.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean
      traffic_shift_percentage:
        description: 'Percentage of traffic to shift to new version (0-100)'
        required: false
        default: '10'
        type: string

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  PYTHON_VERSION: '3.9'
  API_WORKING_DIR: 'services/api'
  AWS_REGION: us-east-1

jobs:
  detect-changes:
    name: Detect API Changes
    runs-on: ubuntu-latest
    outputs:
      api_changed: ${{ steps.changes.outputs.api_changed }}
      should_deploy: ${{ steps.deploy-decision.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect API changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ inputs.force_deploy }}" == "true" ]; then
              echo "api_changed=true" >> $GITHUB_OUTPUT
              echo "Force deployment requested"
            else
              echo "api_changed=true" >> $GITHUB_OUTPUT
              echo "Manual dispatch - assuming changes"
            fi
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "api_changed=true" >> $GITHUB_OUTPUT
            echo "Pull request - running tests and validation"
          else
            # Check for changes in API directory or workflow
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || echo "")

            if [ -z "$CHANGED_FILES" ]; then
              # If we can't detect changes (e.g., first push), assume changes
              echo "api_changed=true" >> $GITHUB_OUTPUT
              echo "Cannot detect changes - assuming API changes"
            elif echo "$CHANGED_FILES" | grep -q "^services/api/\|^\.github/workflows/api-ci\.yml"; then
              echo "api_changed=true" >> $GITHUB_OUTPUT
              echo "API changes detected"
            else
              echo "api_changed=false" >> $GITHUB_OUTPUT
              echo "No API changes detected"
            fi
          fi

      - name: Generate version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION="main-$(git rev-parse --short ${{ github.sha }})-$(date +%Y%m%d-%H%M%S)"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

      - name: Determine deployment decision
        id: deploy-decision
        run: |
          if [ "${{ steps.changes.outputs.api_changed }}" == "true" ] && [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Will deploy to production"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ steps.changes.outputs.api_changed }}" == "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Will deploy via manual dispatch"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "Will not deploy"
          fi

  dependency-security-scan:
    name: API Dependency Security Scan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.api_changed == 'true'
    outputs:
      security_passed: ${{ steps.security-check.outputs.security_passed }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install security scanning tools
        run: |
          pip install safety pip-audit bandit[toml]

      - name: Run Safety scan on API dependencies
        id: safety-scan
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running Safety scan on API dependencies..."
          if [ -f requirements.txt ]; then
            safety check -r requirements.txt --json --output ../safety-api.json || echo "safety_failed=true" >> $GITHUB_OUTPUT
          else
            echo "No requirements.txt found"
            echo '[]' > ../safety-api.json
          fi

          cd ..

          if [ -f safety-api.json ]; then
            SAFETY_VULNS=$(jq '. | length' safety-api.json 2>/dev/null || echo "0")
            echo "safety_vulnerabilities=$SAFETY_VULNS" >> $GITHUB_OUTPUT
            echo "Safety vulnerabilities found: $SAFETY_VULNS"
          fi

      - name: Run pip-audit scan
        id: pip-audit-scan
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running pip-audit scan..."
          if [ -f requirements.txt ]; then
            pip-audit --requirement requirements.txt --format json --output ../pip-audit-api.json || echo "pip_audit_failed=true" >> $GITHUB_OUTPUT
          else
            echo "No requirements.txt found"
            echo '[]' > ../pip-audit-api.json
          fi

          cd ..

          if [ -f pip-audit-api.json ]; then
            PIP_AUDIT_VULNS=$(jq '. | length' pip-audit-api.json 2>/dev/null || echo "0")
            echo "pip_audit_vulnerabilities=$PIP_AUDIT_VULNS" >> $GITHUB_OUTPUT
            echo "pip-audit vulnerabilities found: $PIP_AUDIT_VULNS"
          fi

      - name: Run Bandit SAST scan
        id: bandit-scan
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running Bandit SAST scan on API code..."
          bandit -r . -f json -o ../bandit-api.json || echo "bandit_failed=true" >> $GITHUB_OUTPUT

          cd ..

          if [ -f bandit-api.json ]; then
            BANDIT_ISSUES=$(jq '.results | length' bandit-api.json 2>/dev/null || echo "0")
            BANDIT_HIGH=$(jq '[.results[] | select(.issue_severity == "HIGH")] | length' bandit-api.json 2>/dev/null || echo "0")
            BANDIT_MEDIUM=$(jq '[.results[] | select(.issue_severity == "MEDIUM")] | length' bandit-api.json 2>/dev/null || echo "0")

            echo "bandit_issues=$BANDIT_ISSUES" >> $GITHUB_OUTPUT
            echo "bandit_high=$BANDIT_HIGH" >> $GITHUB_OUTPUT
            echo "bandit_medium=$BANDIT_MEDIUM" >> $GITHUB_OUTPUT

            echo "Bandit SAST results:"
            echo "- Total issues: $BANDIT_ISSUES"
            echo "- High severity: $BANDIT_HIGH"
            echo "- Medium severity: $BANDIT_MEDIUM"
          fi

      - name: Check security status
        id: security-check
        run: |
          SAFETY_VULNS="${{ steps.safety-scan.outputs.safety_vulnerabilities || '0' }}"
          PIP_AUDIT_VULNS="${{ steps.pip-audit-scan.outputs.pip_audit_vulnerabilities || '0' }}"
          BANDIT_HIGH="${{ steps.bandit-scan.outputs.bandit_high || '0' }}"

          # Fail if critical security issues found
          if [ "$SAFETY_VULNS" -gt 0 ] || [ "$PIP_AUDIT_VULNS" -gt 0 ] || [ "$BANDIT_HIGH" -gt 0 ]; then
            echo "security_passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Critical security issues found - blocking build"
          else
            echo "security_passed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Security scan passed"
          fi

      - name: Upload API security results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-security-results-${{ github.run_id }}
          path: |
            safety-api.json
            pip-audit-api.json
            bandit-api.json
          retention-days: 30

      - name: Generate API security summary
        run: |
          SAFETY_VULNS="${{ steps.safety-scan.outputs.safety_vulnerabilities || '0' }}"
          PIP_AUDIT_VULNS="${{ steps.pip-audit-scan.outputs.pip_audit_vulnerabilities || '0' }}"
          BANDIT_ISSUES="${{ steps.bandit-scan.outputs.bandit_issues || '0' }}"
          BANDIT_HIGH="${{ steps.bandit-scan.outputs.bandit_high || '0' }}"
          BANDIT_MEDIUM="${{ steps.bandit-scan.outputs.bandit_medium || '0' }}"

          echo "## üîí API Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Dependency Security" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Vulnerabilities Found |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Safety | $SAFETY_VULNS |" >> $GITHUB_STEP_SUMMARY
          echo "| pip-audit | $PIP_AUDIT_VULNS |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### SAST Results (Bandit)" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| High | $BANDIT_HIGH |" >> $GITHUB_STEP_SUMMARY
          echo "| Medium | $BANDIT_MEDIUM |" >> $GITHUB_STEP_SUMMARY
          echo "| Total | $BANDIT_ISSUES |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$SAFETY_VULNS" -gt 0 ] || [ "$PIP_AUDIT_VULNS" -gt 0 ] || [ "$BANDIT_HIGH" -gt 0 ]; then
            echo "üö® **Critical security issues found!** Build will be blocked." >> $GITHUB_STEP_SUMMARY
          elif [ "$BANDIT_MEDIUM" -gt 0 ]; then
            echo "‚ö†Ô∏è **Medium severity issues found!** Review recommended." >> $GITHUB_STEP_SUMMARY
          else
            echo "‚úÖ **No critical security issues found.**" >> $GITHUB_STEP_SUMMARY
          fi

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [detect-changes, dependency-security-scan]
    if: needs.detect-changes.outputs.api_changed == 'true' && inputs.skip_tests != true && needs.dependency-security-scan.outputs.security_passed == 'true'
    outputs:
      test_results: ${{ steps.test-summary.outputs.results }}
      coverage_percentage: ${{ steps.coverage.outputs.percentage }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_USER: testuser
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          cd ${{ env.API_WORKING_DIR }}
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio httpx

      - name: Set up test environment
        run: |
          cd ${{ env.API_WORKING_DIR }}

          # Create test environment file
          cat > .env.test << EOF
          DATABASE_URL=postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL=redis://localhost:6379/0
          ENVIRONMENT=test
          LOG_LEVEL=DEBUG
          EOF

      - name: Run linting
        run: |
          cd ${{ env.API_WORKING_DIR }}
          pip install ruff black mypy

          echo "Running Black formatter check..."
          black --check --diff .

          echo "Running Ruff linter..."
          ruff check .

          echo "Running MyPy type checking..."
          mypy . --ignore-missing-imports || true

      - name: Run unit tests
        id: unit-tests
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running unit tests..."
          pytest tests/unit/ -v --tb=short --cov=app --cov-report=xml --cov-report=term-missing \
            --cov-report=html --cov-fail-under=80 --junitxml=unit-test-results.xml \
            --maxfail=10 --durations=10 || echo "unit_tests_failed=true" >> $GITHUB_OUTPUT

          # Generate coverage badge data
          if [ -f coverage.xml ]; then
            COVERAGE_PERCENT=$(python -c "
            import xml.etree.ElementTree as ET
            try:
                tree = ET.parse('coverage.xml')
                root = tree.getroot()
                coverage = float(root.attrib.get('line-rate', '0')) * 100
                print(f'{coverage:.1f}')
            except:
                print('0.0')
            ")
            echo "unit_coverage=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
          fi

      - name: Run integration tests
        id: integration-tests
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379/0
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running integration tests..."
          pytest tests/integration/ -v --tb=short --maxfail=5 --durations=10 \
            --junitxml=integration-test-results.xml || echo "integration_tests_failed=true" >> $GITHUB_OUTPUT

          # Count integration test results
          if [ -f integration-test-results.xml ]; then
            INTEGRATION_TESTS=$(python -c "
            import xml.etree.ElementTree as ET
            try:
                tree = ET.parse('integration-test-results.xml')
                root = tree.getroot()
                tests = root.attrib.get('tests', '0')
                failures = root.attrib.get('failures', '0')
                errors = root.attrib.get('errors', '0')
                print(f'tests={tests},failures={failures},errors={errors}')
            except:
                print('tests=0,failures=0,errors=0')
            ")
            echo "integration_results=$INTEGRATION_TESTS" >> $GITHUB_OUTPUT
          fi

      - name: Run API endpoint tests
        id: api-tests
        env:
          DATABASE_URL: postgresql://testuser:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379/0
        run: |
          cd ${{ env.API_WORKING_DIR }}

          echo "Running API endpoint tests..."
          pytest tests/api/ -v --tb=short --maxfail=5 --durations=10 \
            --junitxml=api-test-results.xml || echo "api_tests_failed=true" >> $GITHUB_OUTPUT

          # Count API test results
          if [ -f api-test-results.xml ]; then
            API_TESTS=$(python -c "
            import xml.etree.ElementTree as ET
            try:
                tree = ET.parse('api-test-results.xml')
                root = tree.getroot()
                tests = root.attrib.get('tests', '0')
                failures = root.attrib.get('failures', '0')
                errors = root.attrib.get('errors', '0')
                print(f'tests={tests},failures={failures},errors={errors}')
            except:
                print('tests=0,failures=0,errors=0')
            ")
            echo "api_results=$API_TESTS" >> $GITHUB_OUTPUT
          fi

      - name: Calculate test coverage
        id: coverage
        run: |
          cd ${{ env.API_WORKING_DIR }}

          if [ -f coverage.xml ]; then
            # Extract coverage percentage from XML
            COVERAGE=$(python -c "
            import xml.etree.ElementTree as ET
            tree = ET.parse('coverage.xml')
            root = tree.getroot()
            coverage = root.attrib.get('line-rate', '0')
            print(f'{float(coverage) * 100:.1f}')
            " 2>/dev/null || echo "0.0")

            echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
            echo "Test coverage: $COVERAGE%"
          else
            echo "percentage=0.0" >> $GITHUB_OUTPUT
            echo "No coverage report found"
          fi

      - name: Upload test results and coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: api-test-results-${{ needs.detect-changes.outputs.version }}
          path: |
            ${{ env.API_WORKING_DIR }}/*test-results.xml
            ${{ env.API_WORKING_DIR }}/coverage.xml
            ${{ env.API_WORKING_DIR }}/htmlcov/
          retention-days: 30

      - name: Publish test results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: API Test Results
          path: '${{ env.API_WORKING_DIR }}/*test-results.xml'
          reporter: java-junit
          fail-on-error: false

      - name: Generate test summary
        id: test-summary
        run: |
          cd ${{ env.API_WORKING_DIR }}

          UNIT_STATUS="‚úÖ Passed"
          INTEGRATION_STATUS="‚úÖ Passed"
          API_STATUS="‚úÖ Passed"
          OVERALL_STATUS="‚úÖ All tests passed"

          # Parse test results
          UNIT_COVERAGE="${{ steps.unit-tests.outputs.unit_coverage || '0.0' }}"
          INTEGRATION_RESULTS="${{ steps.integration-tests.outputs.integration_results || 'tests=0,failures=0,errors=0' }}"
          API_RESULTS="${{ steps.api-tests.outputs.api_results || 'tests=0,failures=0,errors=0' }}"

          if [ "${{ steps.unit-tests.outputs.unit_tests_failed }}" == "true" ]; then
            UNIT_STATUS="‚ùå Failed"
            OVERALL_STATUS="‚ùå Tests failed"
          fi

          if [ "${{ steps.integration-tests.outputs.integration_tests_failed }}" == "true" ]; then
            INTEGRATION_STATUS="‚ùå Failed"
            OVERALL_STATUS="‚ùå Tests failed"
          fi

          if [ "${{ steps.api-tests.outputs.api_tests_failed }}" == "true" ]; then
            API_STATUS="‚ùå Failed"
            OVERALL_STATUS="‚ùå Tests failed"
          fi

          RESULTS="Unit Tests: $UNIT_STATUS | Integration Tests: $INTEGRATION_STATUS | API Tests: $API_STATUS"
          echo "results=$RESULTS" >> $GITHUB_OUTPUT

          echo "## üß™ API Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Suites" >> $GITHUB_STEP_SUMMARY
          echo "| Test Suite | Status | Coverage/Results |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|------------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | $UNIT_STATUS | ${UNIT_COVERAGE}% coverage |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | $INTEGRATION_STATUS | $INTEGRATION_RESULTS |" >> $GITHUB_STEP_SUMMARY
          echo "| API Tests | $API_STATUS | $API_RESULTS |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Quality Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- **Code Coverage:** ${UNIT_COVERAGE}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Coverage Threshold:** 80%" >> $GITHUB_STEP_SUMMARY

          # Coverage status
          COVERAGE_FLOAT=$(echo "$UNIT_COVERAGE" | bc -l 2>/dev/null || echo "0")
          if (( $(echo "$COVERAGE_FLOAT >= 80" | bc -l) )); then
            echo "- **Coverage Status:** ‚úÖ Meets threshold" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Coverage Status:** ‚ö†Ô∏è Below threshold" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Overall Status" >> $GITHUB_STEP_SUMMARY
          echo "$OVERALL_STATUS" >> $GITHUB_STEP_SUMMARY

          # Fail the job if any tests failed
          if [ "${{ steps.unit-tests.outputs.unit_tests_failed }}" == "true" ] || \
             [ "${{ steps.integration-tests.outputs.integration_tests_failed }}" == "true" ] || \
             [ "${{ steps.api-tests.outputs.api_tests_failed }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå **Deployment blocked due to test failures**" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Ready for deployment**" >> $GITHUB_STEP_SUMMARY
          fi

  build-package:
    name: Build Lambda Package
    runs-on: ubuntu-latest
    needs: [detect-changes, test]
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    outputs:
      package_s3_key: ${{ steps.upload-package.outputs.s3_key }}
      package_version: ${{ steps.package.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.GITHUB_API_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-APIDeploy-Build-${{ github.run_id }}

      - name: Create Lambda deployment package
        id: package
        run: |
          cd ${{ env.API_WORKING_DIR }}

          # Create deployment directory
          mkdir -p deployment/

          # Install dependencies
          pip install -r requirements.txt -t deployment/

          # Copy application code
          cp -r *.py deployment/
          cp -r packages/ deployment/ 2>/dev/null || echo "No packages directory"

          # Create Lambda handler wrapper if it doesn't exist
          if [ ! -f deployment/lambda_handler.py ]; then
            cat > deployment/lambda_handler.py << 'EOF'
          import json
          from mangum import Mangum
          from main import app

          # Create the Mangum handler
          handler = Mangum(app, lifespan="off")

          def lambda_handler(event, context):
              """AWS Lambda handler function"""
              return handler(event, context)
          EOF
          fi

          # Install mangum for Lambda integration
          pip install mangum -t deployment/

          # Create deployment package
          cd deployment/
          zip -r ../api-deployment-${{ needs.detect-changes.outputs.version }}.zip . -x "*.pyc" "*/__pycache__/*"
          cd ..

          PACKAGE_SIZE=$(du -h api-deployment-${{ needs.detect-changes.outputs.version }}.zip | cut -f1)
          echo "version=${{ needs.detect-changes.outputs.version }}" >> $GITHUB_OUTPUT
          echo "size=$PACKAGE_SIZE" >> $GITHUB_OUTPUT
          echo "Package created: api-deployment-${{ needs.detect-changes.outputs.version }}.zip ($PACKAGE_SIZE)"

      - name: Upload package to S3
        id: upload-package
        run: |
          cd ${{ env.API_WORKING_DIR }}

          # Get deployment bucket
          DEPLOYMENT_BUCKET=$(aws s3api list-buckets --query "Buckets[?contains(Name, 'deployment')].Name" --output text | head -1)

          if [ -z "$DEPLOYMENT_BUCKET" ]; then
            echo "Error: Could not find deployment S3 bucket"
            exit 1
          fi

          S3_KEY="api-packages/api-deployment-${{ needs.detect-changes.outputs.version }}.zip"

          # Upload package
          aws s3 cp api-deployment-${{ needs.detect-changes.outputs.version }}.zip s3://$DEPLOYMENT_BUCKET/$S3_KEY

          echo "s3_key=$S3_KEY" >> $GITHUB_OUTPUT
          echo "bucket=$DEPLOYMENT_BUCKET" >> $GITHUB_OUTPUT
          echo "Package uploaded to s3://$DEPLOYMENT_BUCKET/$S3_KEY"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-deployment-package-${{ needs.detect-changes.outputs.version }}
          path: ${{ env.API_WORKING_DIR }}/api-deployment-${{ needs.detect-changes.outputs.version }}.zip
          retention-days: 30

  blue-green-deploy:
    name: Blue/Green Deployment
    runs-on: ubuntu-latest
    needs: [detect-changes, test, build-package]
    if: |
      always() &&
      needs.detect-changes.outputs.should_deploy == 'true' &&
      needs.build-package.result == 'success'
    environment:
      name: ${{ inputs.environment || 'production' }}-api
      url: ${{ steps.deployment-urls.outputs.api_url }}
    outputs:
      deployment_status: ${{ steps.traffic-switch.outputs.status }}
      blue_version: ${{ steps.get-current.outputs.blue_version }}
      green_version: ${{ steps.deploy-green.outputs.green_version }}
      api_url: ${{ steps.deployment-urls.outputs.api_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.GITHUB_API_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-APIDeploy-BlueGreen-${{ github.run_id }}

      - name: Get Lambda function configuration
        id: lambda-config
        run: |
          FUNCTION_NAME="pdf-accessibility-${{ inputs.environment || 'prod' }}-api"
          echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "Lambda function: $FUNCTION_NAME"

      - name: Check if Lambda function exists
        id: check-function
        run: |
          if aws lambda get-function --function-name ${{ steps.lambda-config.outputs.function_name }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Lambda function exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Lambda function does not exist - deployment will be skipped"
            exit 1
          fi

      - name: Get current deployment state (Blue)
        id: get-current
        run: |
          # Get current LIVE alias version (Blue)
          BLUE_VERSION=$(aws lambda get-alias \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --name LIVE \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "1")

          echo "blue_version=$BLUE_VERSION" >> $GITHUB_OUTPUT
          echo "Current LIVE version (Blue): $BLUE_VERSION"

          # Get current STAGING alias version if it exists
          STAGING_VERSION=$(aws lambda get-alias \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --name STAGING \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "")

          echo "staging_version=$STAGING_VERSION" >> $GITHUB_OUTPUT
          echo "Current STAGING version: ${STAGING_VERSION:-'None'}"

      - name: Deploy new version (Green)
        id: deploy-green
        run: |
          # Update function code with new package
          S3_BUCKET=$(echo "${{ needs.build-package.outputs.package_s3_key }}" | cut -d'/' -f1)
          S3_KEY="${{ needs.build-package.outputs.package_s3_key }}"

          # Get the deployment bucket name
          DEPLOYMENT_BUCKET=$(aws s3api list-buckets --query "Buckets[?contains(Name, 'deployment')].Name" --output text | head -1)

          echo "Updating function code from s3://$DEPLOYMENT_BUCKET/$S3_KEY"

          aws lambda update-function-code \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --s3-bucket "$DEPLOYMENT_BUCKET" \
            --s3-key "$S3_KEY" \
            --output json > update_result.json

          # Wait for update to complete
          echo "Waiting for function update to complete..."
          aws lambda wait function-updated \
            --function-name ${{ steps.lambda-config.outputs.function_name }}

          # Publish new version
          echo "Publishing new version..."
          PUBLISH_RESULT=$(aws lambda publish-version \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --description "API deployment from commit ${{ github.sha }} - Blue/Green deployment" \
            --output json)

          GREEN_VERSION=$(echo "$PUBLISH_RESULT" | jq -r '.Version')
          GREEN_ARN=$(echo "$PUBLISH_RESULT" | jq -r '.FunctionArn')

          echo "green_version=$GREEN_VERSION" >> $GITHUB_OUTPUT
          echo "green_arn=$GREEN_ARN" >> $GITHUB_OUTPUT
          echo "New version (Green) deployed: $GREEN_VERSION"

      - name: Update STAGING alias to Green version
        id: update-staging
        run: |
          # Update or create STAGING alias to point to Green version
          if aws lambda get-alias --function-name ${{ steps.lambda-config.outputs.function_name }} --name STAGING >/dev/null 2>&1; then
            echo "Updating existing STAGING alias to Green version..."
            aws lambda update-alias \
              --function-name ${{ steps.lambda-config.outputs.function_name }} \
              --name STAGING \
              --function-version ${{ steps.deploy-green.outputs.green_version }} \
              --description "Green version for testing - ${{ github.sha }}"
          else
            echo "Creating new STAGING alias for Green version..."
            aws lambda create-alias \
              --function-name ${{ steps.lambda-config.outputs.function_name }} \
              --name STAGING \
              --function-version ${{ steps.deploy-green.outputs.green_version }} \
              --description "Green version for testing - ${{ github.sha }}"
          fi

          echo "STAGING alias updated to Green version ${{ steps.deploy-green.outputs.green_version }}"

      - name: Run health checks on Green version
        id: health-check-green
        run: |
          echo "Running health checks on Green version (STAGING)..."

          # Health check payload
          HEALTH_PAYLOAD='{"httpMethod": "GET", "path": "/health", "headers": {"Host": "api.example.com"}}'

          # Run multiple health checks
          SUCCESS_COUNT=0
          TOTAL_CHECKS=5

          for i in $(seq 1 $TOTAL_CHECKS); do
            echo "Health check attempt $i/$TOTAL_CHECKS..."

            INVOKE_RESULT=$(aws lambda invoke \
              --function-name ${{ steps.lambda-config.outputs.function_name }}:STAGING \
              --payload "$HEALTH_PAYLOAD" \
              --output json \
              response_$i.json)

            STATUS_CODE=$(echo "$INVOKE_RESULT" | jq -r '.StatusCode')

            if [ "$STATUS_CODE" = "200" ]; then
              # Check response content
              if [ -f response_$i.json ]; then
                RESPONSE_BODY=$(cat response_$i.json)

                # Parse response and check for healthy status
                if echo "$RESPONSE_BODY" | jq -e '.statusCode == 200' >/dev/null 2>&1 || \
                   echo "$RESPONSE_BODY" | grep -q '"status".*"healthy"'; then
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  echo "‚úÖ Health check $i passed"
                else
                  echo "‚ùå Health check $i failed - unexpected response: $RESPONSE_BODY"
                fi
              else
                echo "‚ùå Health check $i failed - no response file"
              fi
            else
              echo "‚ùå Health check $i failed - status code: $STATUS_CODE"
            fi

            # Wait between checks
            if [ $i -lt $TOTAL_CHECKS ]; then
              sleep 10
            fi
          done

          echo "Health check results: $SUCCESS_COUNT/$TOTAL_CHECKS passed"

          # Require at least 80% success rate
          MIN_SUCCESS=$((TOTAL_CHECKS * 80 / 100))

          if [ $SUCCESS_COUNT -ge $MIN_SUCCESS ]; then
            echo "health_status=passed" >> $GITHUB_OUTPUT
            echo "‚úÖ Health checks passed ($SUCCESS_COUNT/$TOTAL_CHECKS)"
          else
            echo "health_status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Health checks failed ($SUCCESS_COUNT/$TOTAL_CHECKS) - minimum required: $MIN_SUCCESS"
            exit 1
          fi

      - name: Gradual traffic shifting
        id: traffic-switch
        if: steps.health-check-green.outputs.health_status == 'passed'
        run: |
          echo "Starting gradual traffic shift from Blue to Green..."

          TRAFFIC_PERCENTAGE="${{ inputs.traffic_shift_percentage || '10' }}"

          # Validate traffic percentage
          if ! [[ "$TRAFFIC_PERCENTAGE" =~ ^[0-9]+$ ]] || [ "$TRAFFIC_PERCENTAGE" -lt 0 ] || [ "$TRAFFIC_PERCENTAGE" -gt 100 ]; then
            echo "Invalid traffic percentage: $TRAFFIC_PERCENTAGE. Using default 10%"
            TRAFFIC_PERCENTAGE=10
          fi

          echo "Shifting $TRAFFIC_PERCENTAGE% of traffic to Green version..."

          # Calculate weights for weighted routing
          GREEN_WEIGHT=$(echo "scale=2; $TRAFFIC_PERCENTAGE / 100" | bc)
          BLUE_WEIGHT=$(echo "scale=2; (100 - $TRAFFIC_PERCENTAGE) / 100" | bc)

          # Update LIVE alias with weighted routing
          aws lambda update-alias \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --name LIVE \
            --function-version ${{ steps.get-current.outputs.blue_version }} \
            --routing-config "AdditionalVersionWeights={\"${{ steps.deploy-green.outputs.green_version }}\":$GREEN_WEIGHT}" \
            --description "Blue/Green deployment - $TRAFFIC_PERCENTAGE% traffic to Green (${{ steps.deploy-green.outputs.green_version }})"

          echo "Traffic routing updated:"
          echo "- Blue version ${{ steps.get-current.outputs.blue_version }}: $((100 - TRAFFIC_PERCENTAGE))%"
          echo "- Green version ${{ steps.deploy-green.outputs.green_version }}: $TRAFFIC_PERCENTAGE%"

          echo "status=traffic_shifted" >> $GITHUB_OUTPUT
          echo "blue_weight=$BLUE_WEIGHT" >> $GITHUB_OUTPUT
          echo "green_weight=$GREEN_WEIGHT" >> $GITHUB_OUTPUT

      - name: Monitor Green version performance
        id: monitor-green
        if: steps.traffic-switch.outputs.status == 'traffic_shifted'
        run: |
          echo "Monitoring Green version performance for 2 minutes..."

          # Monitor for 2 minutes with health checks every 30 seconds
          MONITORING_DURATION=120
          CHECK_INTERVAL=30
          CHECKS_COUNT=$((MONITORING_DURATION / CHECK_INTERVAL))

          SUCCESS_COUNT=0

          for i in $(seq 1 $CHECKS_COUNT); do
            echo "Performance check $i/$CHECKS_COUNT..."

            # Health check on LIVE alias (mixed traffic)
            HEALTH_PAYLOAD='{"httpMethod": "GET", "path": "/health", "headers": {"Host": "api.example.com"}}'

            INVOKE_RESULT=$(aws lambda invoke \
              --function-name ${{ steps.lambda-config.outputs.function_name }}:LIVE \
              --payload "$HEALTH_PAYLOAD" \
              --output json \
              monitor_response_$i.json)

            STATUS_CODE=$(echo "$INVOKE_RESULT" | jq -r '.StatusCode')

            if [ "$STATUS_CODE" = "200" ]; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              echo "‚úÖ Performance check $i passed"
            else
              echo "‚ùå Performance check $i failed - status code: $STATUS_CODE"
            fi

            # Wait between checks
            if [ $i -lt $CHECKS_COUNT ]; then
              sleep $CHECK_INTERVAL
            fi
          done

          echo "Performance monitoring results: $SUCCESS_COUNT/$CHECKS_COUNT passed"

          # Require 100% success for production traffic switch
          if [ $SUCCESS_COUNT -eq $CHECKS_COUNT ]; then
            echo "performance_status=passed" >> $GITHUB_OUTPUT
            echo "‚úÖ Green version performance is stable"
          else
            echo "performance_status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Green version performance issues detected"
            exit 1
          fi

      - name: Complete traffic switch or rollback
        id: complete-switch
        if: always()
        run: |
          if [ "${{ steps.monitor-green.outputs.performance_status }}" = "passed" ]; then
            echo "‚úÖ Completing traffic switch to Green version..."

            # Switch 100% traffic to Green version
            aws lambda update-alias \
              --function-name ${{ steps.lambda-config.outputs.function_name }} \
              --name LIVE \
              --function-version ${{ steps.deploy-green.outputs.green_version }} \
              --description "Blue/Green deployment completed - 100% traffic to Green (${{ steps.deploy-green.outputs.green_version }})"

            echo "üéâ Blue/Green deployment completed successfully!"
            echo "LIVE alias now points to Green version ${{ steps.deploy-green.outputs.green_version }}"
            echo "final_status=success" >> $GITHUB_OUTPUT

          else
            echo "‚ùå Rolling back to Blue version due to performance issues..."

            # Rollback to Blue version (remove weighted routing)
            aws lambda update-alias \
              --function-name ${{ steps.lambda-config.outputs.function_name }} \
              --name LIVE \
              --function-version ${{ steps.get-current.outputs.blue_version }} \
              --description "Rollback to Blue version ${{ steps.get-current.outputs.blue_version }} due to Green version issues"

            echo "üîÑ Rollback completed - LIVE alias restored to Blue version ${{ steps.get-current.outputs.blue_version }}"
            echo "final_status=rollback" >> $GITHUB_OUTPUT

            # Clean up failed Green version
            echo "Cleaning up failed Green version..."
            aws lambda delete-function \
              --function-name ${{ steps.lambda-config.outputs.function_name }}:${{ steps.deploy-green.outputs.green_version }} || true

            exit 1
          fi

      - name: Get deployment URLs
        id: deployment-urls
        run: |
          # Get API Gateway URL from Lambda function tags or environment
          API_URL=$(aws lambda get-function \
            --function-name ${{ steps.lambda-config.outputs.function_name }} \
            --query 'Tags.ApiGatewayUrl' \
            --output text 2>/dev/null || echo "")

          if [ -z "$API_URL" ] || [ "$API_URL" = "None" ]; then
            # Fallback: construct URL from API Gateway
            API_ID=$(aws apigateway get-rest-apis \
              --query "items[?contains(name, 'pdf-accessibility')].id" \
              --output text | head -1)

            if [ -n "$API_ID" ] && [ "$API_ID" != "None" ]; then
              API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
            else
              API_URL="https://api.example.com"
            fi
          fi

          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "API URL: $API_URL"

      - name: Generate deployment summary
        if: always()
        run: |
          echo "## üöÄ Blue/Green API Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.detect-changes.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- üîµ Blue Version: ${{ steps.get-current.outputs.blue_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- üü¢ Green Version: ${{ steps.deploy-green.outputs.green_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- üåê API URL: ${{ steps.deployment-urls.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.complete-switch.outputs.final_status }}" = "success" ]; then
            echo "**Status:** ‚úÖ Deployment successful - 100% traffic on Green version" >> $GITHUB_STEP_SUMMARY
            echo "**Traffic:** 100% ‚Üí Green version ${{ steps.deploy-green.outputs.green_version }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.complete-switch.outputs.final_status }}" = "rollback" ]; then
            echo "**Status:** üîÑ Deployment rolled back due to performance issues" >> $GITHUB_STEP_SUMMARY
            echo "**Traffic:** 100% ‚Üí Blue version ${{ steps.get-current.outputs.blue_version }} (rollback)" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** ‚ùå Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Health Checks:** ${{ steps.health-check-green.outputs.health_status || 'Not run' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Performance Monitoring:** ${{ steps.monitor-green.outputs.performance_status || 'Not run' }}" >> $GITHUB_STEP_SUMMARY

  cleanup:
    name: Cleanup Old Versions
    runs-on: ubuntu-latest
    needs: [detect-changes, blue-green-deploy]
    if: |
      always() &&
      needs.blue-green-deploy.outputs.deployment_status == 'success' &&
      needs.blue-green-deploy.result == 'success'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.GITHUB_API_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-APIDeploy-Cleanup-${{ github.run_id }}

      - name: Clean up old Lambda versions
        run: |
          FUNCTION_NAME="pdf-accessibility-${{ inputs.environment || 'prod' }}-api"

          echo "Cleaning up old Lambda versions for $FUNCTION_NAME..."

          # Get all versions except $LATEST
          VERSIONS=$(aws lambda list-versions-by-function \
            --function-name $FUNCTION_NAME \
            --query 'Versions[?Version != `$LATEST`].Version' \
            --output text)

          # Keep the latest 5 versions plus current LIVE and STAGING
          LIVE_VERSION=$(aws lambda get-alias \
            --function-name $FUNCTION_NAME \
            --name LIVE \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "")

          STAGING_VERSION=$(aws lambda get-alias \
            --function-name $FUNCTION_NAME \
            --name STAGING \
            --query 'FunctionVersion' \
            --output text 2>/dev/null || echo "")

          # Sort versions numerically and keep only the oldest ones for deletion
          VERSIONS_TO_DELETE=$(echo "$VERSIONS" | tr ' ' '\n' | sort -n | head -n -5)

          for version in $VERSIONS_TO_DELETE; do
            # Don't delete versions that are currently in use
            if [ "$version" != "$LIVE_VERSION" ] && [ "$version" != "$STAGING_VERSION" ]; then
              echo "Deleting old version: $version"
              aws lambda delete-function \
                --function-name $FUNCTION_NAME:$version || echo "Failed to delete version $version"
            else
              echo "Skipping version $version (currently in use)"
            fi
          done

          echo "Cleanup completed"

  security-monitoring:
    name: Security Monitoring
    runs-on: ubuntu-latest
    needs: [detect-changes, test, build-package, blue-green-deploy]
    if: always() && needs.blue-green-deploy.result == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.GITHUB_API_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-APISecurity-${{ github.run_id }}

      - name: Monitor API security events
        if: secrets.DEPLOYMENT_WEBHOOK_URL != ''
        uses: ./.github/actions/security-monitor
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          aws_region: ${{ env.AWS_REGION }}
          monitoring_duration: '10'
          service_name: 'api'

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs:
      [
        detect-changes,
        test,
        build-package,
        blue-green-deploy,
        security-monitoring,
      ]
    if: always() && needs.detect-changes.outputs.should_deploy == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Notify deployment start
        if: secrets.DEPLOYMENT_WEBHOOK_URL != '' && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'start'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          additional_context: |
            {
              "deployment_type": "api",
              "deployment_strategy": "blue_green",
              "trigger": "${{ github.event_name }}",
              "traffic_shift_percentage": "${{ inputs.traffic_shift_percentage || '10' }}"
            }

      - name: Notify manual approval required
        if: secrets.DEPLOYMENT_WEBHOOK_URL != '' && github.event_name == 'workflow_dispatch' && needs.blue-green-deploy.outputs.deployment_status == 'traffic_shifted'
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'approval_required'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          approval_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          additional_context: |
            {
              "deployment_type": "api",
              "deployment_strategy": "blue_green",
              "blue_version": "${{ needs.blue-green-deploy.outputs.blue_version }}",
              "green_version": "${{ needs.blue-green-deploy.outputs.green_version }}",
              "traffic_percentage": "${{ inputs.traffic_shift_percentage || '10' }}",
              "requires_approval": true
            }

      - name: Notify deployment success
        if: secrets.DEPLOYMENT_WEBHOOK_URL != '' && needs.blue-green-deploy.result == 'success'
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'success'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          deployment_url: ${{ needs.blue-green-deploy.outputs.api_url }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          additional_context: |
            {
              "deployment_type": "api",
              "deployment_strategy": "blue_green",
              "blue_version": "${{ needs.blue-green-deploy.outputs.blue_version }}",
              "green_version": "${{ needs.blue-green-deploy.outputs.green_version }}",
              "deployment_status": "${{ needs.blue-green-deploy.outputs.deployment_status }}",
              "test_results": "${{ needs.test.outputs.test_results }}",
              "coverage_percentage": "${{ needs.test.outputs.coverage_percentage }}",
              "security_status": "${{ needs.security-monitoring.outputs.security_status || 'not_monitored' }}"
            }

      - name: Notify deployment failure
        if: |
          secrets.DEPLOYMENT_WEBHOOK_URL != '' && (
            needs.test.result == 'failure' ||
            needs.build-package.result == 'failure' ||
            needs.blue-green-deploy.result == 'failure'
          )
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'failure'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          error_details: |
            API Blue/Green deployment failed at the following stage:

            ${{ needs.test.result == 'failure' && '‚ùå Testing Stage Failed' || '' }}
            ${{ needs.test.result == 'failure' && format('- Test Results: {0}', needs.test.outputs.test_results) || '' }}
            ${{ needs.test.result == 'failure' && format('- Coverage: {0}%', needs.test.outputs.coverage_percentage) || '' }}

            ${{ needs.build-package.result == 'failure' && '‚ùå Package Build Stage Failed' || '' }}
            ${{ needs.build-package.result == 'failure' && '- Lambda deployment package creation failed' || '' }}
            ${{ needs.build-package.result == 'failure' && '- Check Python dependencies and packaging' || '' }}

            ${{ needs.blue-green-deploy.result == 'failure' && '‚ùå Blue/Green Deployment Stage Failed' || '' }}
            ${{ needs.blue-green-deploy.result == 'failure' && '- Health checks may have failed' || '' }}
            ${{ needs.blue-green-deploy.result == 'failure' && '- Traffic switching was not completed' || '' }}
            ${{ needs.blue-green-deploy.result == 'failure' && '- Blue version remains active' || '' }}

            Automatic rollback has been initiated to maintain service availability.
          additional_context: |
            {
              "deployment_type": "api",
              "deployment_strategy": "blue_green",
              "failure_stage": "${{ needs.test.result == 'failure' && 'testing' || needs.build-package.result == 'failure' && 'packaging' || needs.blue-green-deploy.result == 'failure' && 'deployment' || 'unknown' }}",
              "rollback_status": "automatic",
              "blue_version_active": true,
              "manual_intervention_required": true
            }

      - name: Notify rollback events
        if: secrets.DEPLOYMENT_WEBHOOK_URL != '' && needs.blue-green-deploy.result == 'failure'
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'rollback'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          deployment_url: ${{ needs.blue-green-deploy.outputs.api_url }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          error_details: |
            Blue/Green deployment rollback initiated for API service.

            Rollback Details:
            - Failed Green Version: ${{ needs.blue-green-deploy.outputs.green_version }}
            - Active Blue Version: ${{ needs.blue-green-deploy.outputs.blue_version }}
            - Traffic: 100% routed to Blue (stable) version
            - Service Availability: Maintained throughout rollback

            The failed Green version has been removed and traffic continues
            to flow to the stable Blue version. No service interruption occurred.
          additional_context: |
            {
              "deployment_type": "api",
              "rollback_reason": "deployment_failure",
              "rollback_method": "blue_green_automatic",
              "service_availability": "maintained",
              "failed_version": "${{ needs.blue-green-deploy.outputs.green_version }}",
              "stable_version": "${{ needs.blue-green-deploy.outputs.blue_version }}"
            }

      - name: Notify security alerts
        if: secrets.DEPLOYMENT_WEBHOOK_URL != '' && needs.security-monitoring.outputs.security_status == 'alert'
        uses: ./.github/actions/notify-deployment
        with:
          webhook_url: ${{ secrets.DEPLOYMENT_WEBHOOK_URL }}
          notification_type: 'security_alert'
          service_name: 'api'
          environment: ${{ inputs.environment || 'dev' }}
          version: ${{ needs.detect-changes.outputs.version }}
          commit_sha: ${{ github.sha }}
          deployment_url: ${{ needs.blue-green-deploy.outputs.api_url }}
          workflow_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          security_event: |
            High-priority security events detected during API deployment:

            Security Details:
            - API Endpoint: ${{ needs.blue-green-deploy.outputs.api_url }}
            - Security Status: ${{ needs.security-monitoring.outputs.security_status }}
            - Events Detected: ${{ needs.security-monitoring.outputs.security_events_detected }}
            - Blue Version: ${{ needs.blue-green-deploy.outputs.blue_version }}
            - Green Version: ${{ needs.blue-green-deploy.outputs.green_version }}

            Immediate security review required for both API versions.
            Consider temporarily disabling the API until security review is complete.
          additional_context: |
            {
              "deployment_type": "api",
              "security_level": "critical",
              "api_endpoint": "${{ needs.blue-green-deploy.outputs.api_url }}",
              "blue_version": "${{ needs.blue-green-deploy.outputs.blue_version }}",
              "green_version": "${{ needs.blue-green-deploy.outputs.green_version }}",
              "immediate_action_required": true,
              "recommended_action": "security_review"
            }

      - name: Log notification summary
        run: |
          echo "## üì¢ API Deployment Notifications" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.detect-changes.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment || 'dev' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Strategy:** Blue/Green" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Status:** ${{ needs.blue-green-deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Security Status:** ${{ needs.security-monitoring.outputs.security_status || 'not_monitored' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Notifications Sent:** ${{ secrets.DEPLOYMENT_WEBHOOK_URL != '' && 'Yes' || 'No (webhook not configured)' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.blue-green-deploy.result }}" = "success" ]; then
            echo "‚úÖ **API Blue/Green deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
            echo "üîµ **Blue Version (Previous):** ${{ needs.blue-green-deploy.outputs.blue_version }}" >> $GITHUB_STEP_SUMMARY
            echo "üü¢ **Green Version (New):** ${{ needs.blue-green-deploy.outputs.green_version }}" >> $GITHUB_STEP_SUMMARY
            echo "üìä **Test Coverage:** ${{ needs.test.outputs.coverage_percentage }}%" >> $GITHUB_STEP_SUMMARY
            if [ -n "${{ needs.blue-green-deploy.outputs.api_url }}" ]; then
              echo "üåê **API URL:** ${{ needs.blue-green-deploy.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ùå **API deployment failed**" >> $GITHUB_STEP_SUMMARY
            echo "üîÑ **Rollback Status:** Automatic rollback to Blue version" >> $GITHUB_STEP_SUMMARY
            echo "üìã **Action Required:** Review deployment logs and address issues" >> $GITHUB_STEP_SUMMARY
          fi
